\chapter{Special Rozdils of mathmatics}

\section{АРИФМЕТИКА ВЕЛИКИХ ЧИСЕЛ}

Лекція 1

\subsection{Великі числа. Алгоритми множення та їх порівняння}

У сучасній прикладній математиці часто виникає потреба виконання
операцій з дуже великими числами. Зокрема, в асиметричній криптографії
необхідно працювати з числами, які мають понад 300 десяткових знаків. В той
же час комп’ютер «вміє» робити арифметичні операції з числами, що можуть
бути записані у машинному слові. Так, якщо використовується 32-розрядний
процесор, то найбільше число, що може бути записане у машинне слово,
дорівнює $2^{32} - 1 \approx 4 \cdot 10^9$
(якщо навіть знехтувати тим, що деякі біти слова є
службовими, наприклад, вказують знак числа). Отже, необхідні спеціальні
алгоритми, які б давали змогу виконувати на комп’ютері операції з числами,
які не вміщуються у машинне слово. Крім того, оперування великими числами
сповільнює обчислення, тож алгоритми, які дозволяють підвищити
ефективність виконання таких операцій, є актуальними. Саме цим питанням і
присвячена галузь математики, що називається арифметикою великих чисел.

Великим числом будемо називати число, що не вміщується у машинне
слово.

Нехай A – число, an-1 an-2 … a1 a0 – його цифри у системі числення з
основою b. Будемо записувати це у виді:
A = (an-1 an-2 … a1 a0)b = an-1b
n-1+ an-2 b


Кількість знаків у машинному слові позначимо через k. Розіб’ємо число А на
відрізки по k цифр, починаючи з молодшої цифри:



(якщо кількість цифр числа A у системі числення з основою b не кратна k,
дописуємо зліва необхідну кількість нулів). Кожен відзізок довжини k можна
розуміти як цифру у системі числення з основою B = .
k
b
 Позначимо ці цифри
як

, де t – найближче ціле зверху до п/k. Тоді число А у системі
числення з основою В можна записати як
A = (At-1 At-2 … A1 A0)B = At-1B
t-1+ An-2 B B-1.
 Нас будуть цікавити різні алгоритми множенння чисел та їх порівняння з
точки зору їх складності. Позначимо через T(n) складність алгоритму (кількість
елементарних операцій) при довжині входу п (сумарній довжині чисел, що
подаються на вхід алгоритму). Зазвичай елементарною операцією вважають
множення двох одноцифрових чисел (іноді множення чисел певної довжини
або просто множення будь-яких чисел). Операції додавння та віднімання
виконуються набагато швидше, ніж множення, тому при підрахунку складності
ними нехтують і обчислюють тільки кількість множень.
Множення «стовпчиком»
 Якщо перемножати «стовпчиком» два числа, одне з яких має m цифр, а
друге – k цифр, то множачи кожну цифру другого числа на всі цифри першого,
ми виконуємо загалом  одноцифрових множень. При оцінці складності
вважають, що обидва числа мають однакову довжину n. Так як час виконання
додавань та зсувів не враховується, отримуємо оцінку складності цоьго
алгоритму:
T(n)=O(n
2
).
Алгоритм Карацуби
Алгоритм Карацуби – оди з найпростіших, найзручніших та
найуживаніших алгоритмів швидкого множення. Автором його є Анатолій
Карацуба, який винайшов цей алгоритм у 1962р., коли був студентом МДУ.
Нехай треба перемножити два 2n-значних числа, записаних у системі
числення з основою b:

Позначимо число, що складається з n молодших цифр числа X, через X0, а
число, що складається з n старших цифр, --- через X1. Тоді
Перемножаючи безпосередньо: Х та Y у такому виді, отримуємо:



У правій частині цієї формули маємо 4 множення п-значних чисел.
Карацуба запропонував у формулі (1.1) додати і відняти вираз (X1Y1 +X0Y0):



А в цій формулі --- 3 множення п-значних чисел замість 4-х.

При обчисленні добутків  знову використовують
той самий прийом, розділяючи кожен співмножник на дві частини і
застосовуючи формулу  (якщо кількість цифр у числі непарна, дописують 0
у старшому розряді). Так роблять до тих пір, доки не дійдуть до множення
одноцифрових чисел або принаймні таких чисел, якими зручно оперувати.
Складність алгоритму Карацуби

Оцінимо складність алгоритму Карацуби.
Неважко бачити,що


де сn --- складність додавань, віднімань та множень на степені b, що є просто
дописуванням відповідної кількості нулів до числа (зсув вліво); ця складність
пропорційна n, с – деяка костанта, що не залежить від n.
Доведемо допоміжну нерівність

за індукцією. Виберемо константу  як найбільше з T(2) і с, що фігурує у.
Тоді виконується при --- база індукції.
Викрнаємо крок індукції: .



доведено.
Позначимо  найменше ціле число, що перевищує.


або дуже грубо.
Cкладності деяких відомих алгоритмів множення

За час після появи алгоритму Карацуби з’явилося багато нових
ефективних алгоритмів швидкого множення великих чисел. Нижче наведені
складності найбільш відомих алгоритмів.
У стовпчик:


Алгоритм Карацуби:
Алгоритм Шенхаге-Штрассена
Алгоритм Карпа

Алгоритм Полларда

Як бачимо, найшвидшим є алгоритм Полларда. Існує припущення, що
швидше множити числа вже неможливо. Проте його, як і алгоритм ШенхагеШтрассена, досить складно застосовувати. Тому найбільш популярним, з
огляду на простоту і зручність застосування, і донині є алгоритм Карацуби.
Схема Горнера

Найрозповсюдженіша операція в асиметричній криптографії – піднесення
числа (зазвичай великого) до степеня. Можна підносити число до степеня,
множачи його на себе. Проте це не є ефективним способом навіть при
використанні одного з алгоритмів швидкого множення. Існує дуже ефективний
спосіб піднесення числа до степеня, що називається схемою Горнера. Нехай
треба обчислити Х е
, де Х,е – натуральні числа, е має s цифр у двійковій системі
числення, тобто


цифри у двійковому зображенні числа е.



Обчислимо низку степенів: Х, Х 2

, кожен раз
підносячи до квадрата попереднє значення. Перемножимо ті з цих степенів, для
яких відповідні цифри у двійковому записі числа е дорівнюють 1, тобто



Приклад:
Обчислити Х 100



Таким чином, щоб обчислити Х 100
, потрібно обчислити


а потім перемножити


Отже, для обчислення Х 100 за схемою Горнера потрібно 6+2=8
множень, в той час як при безпосередньому множенні знадобилось би 99
множень. У загальному випадку, коли показник е має s двійкових цифр, то
потрібно s піднесень до квадрата і не більше за s подальших множень. Так як
, то складність схеми Горнера не перевищує 2log2e множень, тобто
асимптотично О() множень.


Більш зручно для програмування схему Горнера можна зобразити у виді


У псевдокоді обчислення за цією формулою можна записати таким чином:

Вхід: 

Вихід: 


Лекція 2

\subsection{Алгоритми швидкої модулярної редукції}

Складність схеми Горнера визначається кількістю множень. Але неважко
бачити, що ці множення не є рівноцінними. Адже якщо Х має k знаків, то Х 2
має 2k знаків і з кожним множенням довжина добутку зростає. Але насправді у
криптографії обчислення робляться у кільцях лишків, тобто потрібно
обчислювати Х
е modп. Якщо після кожного множення брати результат за
модулем, то кількість цифр у добутку не буде перевищувати кількості цифр у
модулі. Однак операція взяття числа за модулем (модулярної редукції) містить
у собі ділення на модуль:
Х modп = Х – [Х/n] n, (2.1)
а ділення – дуже витратна операція, і в обчислювальних алгоритмах її
намагаються уникати. Щоправда, повністю уникнути ділення не вдається, але
існують алгоритми, які дозволяють мінімізувати кількість ділень, наприклад,
звести у схемі Горнера до одного, яке виконується у передобчисленні. Одним із
таких алгоритмів є алгоритм Баррета.
Алгоритм Барретта
Барретт запропонував алгоритм, який дозволяє обчислити r = x mod n для
даних x і n, причому вважається, що n має k цифр, а
x - 2k
цифр у системі
числення з основою b. Алгоритм потребує попереднього обчислення числа

2k
/ n]. Після цього в алгоритмі відсутні «важкі» операції ділення –
залишаються тільки ділення на степінь основи системи числення
b
, які на
практиці реалізуються «легкою» операцією зсуву. При одноразовому виконанні
модулярної редукції (тобто обчислення x mod n) алгоритм Баррета не дає
виграшу за обчислювальною складністю, але при багаторазовому обчисленні
редукції за одним й тим самим модулем (що спостерігається, наприклад, при 
обчисленні
a n
m mod
) він виявляється ефективним, бо  достатньо обчислити
один раз.

Позначимо q=[Х/n]; тоді Х modп = Х – qn.

Барретт запропонував оцінити q наступним чином:

де t --- довільне ціле число у проміжку .

У формулі (2.2) «важке» ділення (на довільне число n) робиться лише при
обчисленні величини . Відмітимо, що не залежить від Х, цю
величину можна обрахувати один раз, винісши дану операцію у
передобчислення, і використовувати для редукції будь-якого числа Х. Решта
ділень мають вид [A/b r ], що означає просто відкидання r молодших цифр числа
A. До того ж можна довести, що
, (2.3)
причому, як показав Барретт, за виконання умови
(2.4)





Наприклад, у схемі Горнера при обчисленні Х е modп умова (2.4) завжди
виконується, бо перемножаються числа, взяті попередньо за модулем п.
Барретт показав, що у (2.2) найкраще брати t =k+1.
Познaчимо  = , і візьмемо t = k +1,
тоді = q = [  ]
Алгоритм Барретта (у псевдокоді)
Передобчислення : = [b
2k
/ n].
Вхід: додатні цілі числа: х –2k-значне, n – k-значне, .
Вихід: r = x mod n.
1. Обчислюємо q1=[x/b
k-1
k+1].
2. Знаходимо, r=x-q3n.
3. Доки rп, цикл: r=r-п.

В результаті завершення циклу отримаємо шукане r= x mod n.
Зауважимо, що крок 3 за умови виконання (2.4) доведеться робити не більше за
2 рази.

\subsection{Алгоритм Монтгомері}

Окрім алгоритму Барретта існує й інший, дуже ефективний, алгоритм
швидкої модулярної редукції – алгоритм Монтгомері. Він базується на теоремі
Монтгомері і дозволяє швидко підрахувати xR-1modn, де x, R, n – натуральні
числа, (R,n)=1. Про те, як використовувати цю можливість для уникнення
багаторазових ділень на n, наприклад, у схемі Горнера, буде сказано пізніше.
Теорема Монтгомері
Нехай R, n – натуральні числа, (R, n)=1.
Тоді для будь-якого цілого х>0 існує ціле число t, таке, що:
1) 
2) – ціле число,

3) = xR-1modn.
 
Доведення
Розглянемо послідовність лишків за mod R:
х mod R, (х+ n) mod R, (х+ 2n) mod R, ..., (х+ (R-1) n) mod R.
Серед цих лишків немає співпадаючих, всі вони різні.
Дійсно, нехай існують 0  такі, що . Тоді
Але це неможливо, так як . Отже, існує

таке, що , тобто,  ділться на . Таким чином,
– ціле число, і ми довели два перших твердження теореми.
Позначимо = с. Тоді = Rс, звідки = Rс modn
с = xR-1 modn= modn (R
-1 modn існує, бо за умовою (R, n)=1), і третє
твердження теореми доведено.
Якщо взяти R таким, що x < Rn, то внаслідок того, що t/ (тв.1теореми)
виконається нерівність: < 2n, і обчислення xR-1modn зведеться до
обчислення – , де  або n. Отже, наша задача – знайти число t і,
якщо n, відняти від дробу n.
Надалі вважатимемо, що х – це 2k-значне число, n – k-значне, R=bk
, де b
– основа системи числення (отже, n має бути взаємно-простим з основою
системи числення!). Зауважимо, що коли х є добутком двох чисел, менших за n
(що має місце у схемі Горнера), то нерівність x < Rn виконується.
Наведений нижче алгоритм швидкого обчислення xR-1modn називається
редукцією Монтгомері і позначається rеdc(x).
Редукція Монтгомері ( rеdc(x) )
x =( x2k - 1…. x0)b, n=( n k – 1...n0)b, t=( t k - 1 … t0)b, R=bk
;
k – ціле
число, отже, чисельник ділиться на b, тобто його молодша цифра доівнює 0. Це
означає, що t0n0 + x0 = 0 mod b, звідки
t0= –n0
-1
x0 modb
або, якщо позначити с0 = – n0
-1
(зауважимо, що (n, b
k
)=1 (n0, b)=1), то
t0=с0 x0 modb.
Таким чином, ми знайшли молодшу цифру числа t. Наступні цифри
знаходяться аналогічно. А саме:
перерахуємо x: x:= x+ t0n. Молодша цифра нового значення x дорівнює 0.
Але так як ділиться і на b
2
(k>1), то t1bn0+ x1b = 0modb
2
. Отже,
t1=с0x1 modb.
Тепер знову перерахуємо x: x:= x+ t1n b і знайдемо t2. І так до t k – 1. Після
останнього кроку отримаємо
x:= xпоч+ t0n+ t1n b + ... + tk-1n b
k-1=0 modb
k
,
де xпоч – початкове значення x. Поділимо x на b
k
і отримаємо
x / b
k= xR-1modn.
У псевдокоді алгоритм редукції Монтгомері виглядає так:
redc(x)
Вхід: n=(n k-1… n0)b, R=bk
, (R, n)=1, с0 = –n0
-1mod b,
x =( x2k - 1 … x0)b, x < Rn.
Результат: xR-1modn.
1. for i:=0 till k-1 do:
1.1. ti=с0xi modb;
1.2. x:= x + tinbi
;
2. x:= x / b
k
;
.
4. Результат: = x=хпоч R
-1modn.
Приклад
Вхід: x=372534, n=627, R=103
(очевидно, x < Rn), c0= –n0









Результат:.
Операція rеdc робиться надзвичайно швидко, бо у всіх множеннях
принаймні один множник є цифрою, а не великим числом; решта операцій ---
зовсім прості.
Тепер розглянемо, як застосовується операція .
Уведемо операцію :
,
тобто операція  обернена до операції :
.
Операція  має такі властивості:
(x у) = (x) (у) ;
(x у) = x уR =  R
-1modn= rеdc(moу)).
Якщо у деякому алгоритмі на вхід подаються числа x modn, у modn, в
результаті отримується величина z modn, а в тілі алгоритму присутні лише
операції додавання, віднімання та множення за modn, то можна на вхід замість
x modn, у modn подати mont(x) та mont(у), а у тілі алгоритму операцію
x у modn замінити на rеdc(mont(xmont(у)). У результаті отримаємо mont(z).
Достатньо до нього застосувати операцію rеdc і будемо мати потрібний
результат z modn. Таким чином, ділення на n потрібно робити лише у
передобчисленнях при обрахуванні mont(x) та mont(у). У тілі ж алгоритму при
додаванні mont(x)+mont(у) modn ділення на n не потрібне, так як mont(x),
, і якщо їх сума більша за n, достатньо лише відняти n. Операція ж
редукції робиться дуже швидко.

Лекція 3

\subsection{Алгоритми швидкої модулярної редукції (продовження)}

Ось псевдокод сполучення схеми Горнера та алгоритму Монтгомері.
Вхід: 

Результат: .

Існує алгоритм , який одночасно виконує редукцію і
множення двох чисел, тобто обчислює , що робить наведений алгоритм
ще більш ефективним.

Алгоритм  (у псевдокоді)
Вхід:

Результат:

Результат:

Приклад

Результат:

Як бачимо, алгоритм MontMul аналогічний алгоритму rеdc і так само є
дуже ефективним.
ti :=(ai + xi у0) с0 modb;
A:=A+ (xi у +tin)b
і
Алгоритм Карацуби (приклад)

2n + b
n
) + (X1-X0)(Y0-Y1)b
n + X0Y0(b
n+1)
Обчислити 1535. X1=19, X0=37; Y1=25, Y0=35.
X1Y1= 1X11=1, X10= 9; Y11=2, Y10 =5.
X1Y1= +10) + (1-9)(5-2)10 +1) =200 + 20 – 240 + 450 + 45= 475.

X1-X0= (19-37) = -18, Y0-Y1 = 10.
(X1-X0)(Y0-Y1) = -[ 1(102+10)+(1-8)(0-1)100+1)] =-(110 +70 +0)= -180.
X0Y0= 10) + (3 -7)(5-3)10+1) =990 – 80 + 385 = 1295.
75(104+102
) - 182+ 1295(102+1)=4910295
4 7 5 0 0 0 0 4 9 2 8 2 9 5
 4 7 5 0 0 1 8 0 0 0
 1 2 9 5 0 0 4 9 1 0 2 9 5
 1 2 9 5
4 9 2 8 2 9 5

Лекція 4

\subsection{Групи та їх властивості. Приклади груп}

Означення 4.1. Групою (
G
, *) називається алгебраїчна
структура з однією операцією *, для якої виконуються умови:
1) операція * асоціативна:

 (a*b)*c = a*(b*c);
2) існує елемент

такий, що для будь-якого

e - одиничний або нейтральний елемент G)
3) для будь-якого

існує елемент


такий, що

обернений до
a
елемент).
Зауваження. Якщо операція * в групі (говорять також групова
операція) --- додавання, то a
-1 позначають --- а і називають
протилежним елементом до елемента а. Замість b + (- а) пишуть
b - a.

Групи з операцією додавання часто називають адитивними
групами, а групи з операцією множення – мультиплікативними.
Проте треба розуміти, що елементами групи можуть бути
математичні об’єкти різної природи (числа з певної множини,
матриці, функції, геометричні фігури тощо), і поняття додавання
або множення є досить умовним.
Надалі, якщо не треба підкреслювати, яка саме операція
використовується в групі, будемо замість a*b писати ab.
Якщо операція в групі
G
комутативна:


то група
G
називається абелевою.
Властивості груп
1) Єдиність нейтрального елемента.
Доведення
2) (аb)
-1= b
-1 a
-1
Доведення
3) Можливість скорочувати: 
 або  a=b.
 са=сb
Доведення
4) Єдиність оберненого елемента
a
G.
Доведення
5)  та .
Доведення
 Означення 4.2. Кількість елементів групи називається її
порядком. Група називається скінченною або нескінченною в
залежності від того, скінченний чи нескінченний її порядок .
Кількість елементів будь-якої множини М будемо позначати | М|,
тож порядок групи теж позначатимемо |G|.
Означення 4.3. Нехай G – група, . Якщо існує таке n N,
що a
n= e, то число  називається порядком
елемента а (у групі G). Якщо не існує такого , що a
 ,
вважається, що . Якщо  , то а називається
елементом скінченного порядку; в іншому випадку а --- елемент
нескінченного порядку.
Зрозуміло, що при 

для будь-якого елемента 
виконується:

. Дійсно, за означенням операції,

k

1:

тому кількість різних степенів елемента а скінченна.
Відповідно, для деяких
l= a
m, тобто a
l – m = e. Отже,
для кожного елемента скінченної групи існує таке , що a
п = е.
Також очевидно, що 

і якщо , то a
n - 1 = a - 1
.
В адитивній групі замість a
n пишуть .

Означення 4.4. Підмножина Н

G називається підгрупою G,
якщо Н є групою відносно операції, заданої на G.
 Кожна група G має дві тривіальні підгрупи:  і G. Всі інші
підгрупи (якщо вони існують) називаються власними.
У нескінченній групі можуть існувати елементи скінченного
порядку. Наприклад, порядок нейтрального елемента будь-якої
групи дорівнює 1.
Теорема 4.1. Нехай (
G
, *) --- група, Н

G. (Н, *) --- група тоді і
тільки тоді, коли .

Доведення
Наведемо кілька прикладів груп, які зустрічаються у криптології.
1. Група лишків за mod т 

--- група відносно операції .
Часто операцію додавання за модулем позначають як .
Скінченні групи можна задавати у вигляді таблиці групової
операції, або таблиці Келі.
Приклад. Таблиця Келі для Z5 = {0, 1, 2, 3, 4} відносно операції
додавання за модулем 5.


2. Групи підстановок
 Означення 4. 5. Підстановкою скінченної множини М
називається взаємно однозначне відображення .
Ототожнимо елементи множини М, кількість елементів якої
дорівнює n , з числами 1,2,..., n. Тоді підстановку можна
записати як матрицю з двома рядками:

де --- переставлені якимось чином
натуральні числа від 1 до n. Це означає, що при відображенні
елемент 1 відображається у елемент , елемент 2 --- у  і т. д.
Будемо називати підстановкою довжини . Кількість таких
підстановок дорівнює .

На множині підстановок довжини n можна ввести операцію
множення таким чином. Якщо у підстановці елемент k
відображається (преходить) у елемент i, a у підстановці елемент
i преходить у елемент j, то у підстановці елемент k
преходить у елемент j. Наприклад,

Неважко зрозуміти, що множина підстановок довжини n із
заданою таким чином операцією утворює групу. (Довести!)
Групу підстановок довжини n називають симетричною (рос. –
симметрической) групою і позначають n .

3. Циклічні групи
Означення 4.6. Група G називається циклічною групою, якщо

Елемент g називають твірним (породжуючим, утворюючим)
елементом групи G, або її генератором, а групу G – циклічною
групою, породженою елементом g, і це позначають як G = .
 Наприклад, якщо аG, то всі неспівпадаючі елементи виду а

k  утворюють циклічну групу . Так, множина цілих чисел
є нескінченною циклічною групою, породженою одиницею .

Вірно також, що   . Очевидно, що інших твірних ця
група не має. Чи є в неї власні циклічні підгрупи? Скінченна група
є також циклічною, її твірними є всі ненульові
елементи. А чи є циклічною група  

Будь-яка нескінченна циклічна група G з твірним елементом а
взаємно-однозначно відображається на (Z, +) відображенням a
k

k,
.
Властивості циклічних груп

Теорема 4.2 (про властивості циклічних груп): нехай G ---
циклічна група, Н – її підгрупа, а --- твірний елемент групи G. Тоді
справедливі наступні твердження.

1. Кожна підгрупа циклічної групи також є циклічною.

2. Нехай G скінченна,  . Тоді:

2.1.

2.2. для будь-якого натурального числа d, що є дільником числа
т, група G містить:

2.2.1. єдину підгрупу порядку d;

2.2.2. рівно  елементів порядку d (де  – функція
Ойлера): це елементи виду а, де

та (r, d) = 1; зокрема, існує
рівно  твірних елементів: це елементи виду а
r
, де (r, m) =1.
Приклад.

Кількість твірних групи дорівнює . Це елементи a,
a
3

, всі вони мають порядок 10.
Тривіальні підгрупи: та ;
власні підгрупи:

--- підгрупа порядку 5, у ній
 твірних та --- підгрупа порядку 2, у ній (2) = 1
твірний.

Порядки всіх елементів ділять порядок групи. Кожен елемент є
твірним деякої підгрупи.



